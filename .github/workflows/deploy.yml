name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  test:
    name: Test Application
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: marketplace_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.23'
          cache: true

      - name: Get dependencies
        run: go mod download

      - name: Run tests
        run: go test -v ./...
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: postgres
          DB_PASSWORD: postgres
          DB_NAME: marketplace_test

  build_and_push:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ secrets.REGISTRY_USER }}
          password: ${{ secrets.REGISTRY_PASS }}

      - name: Get Version from Git
        id: get_version
        run: echo "VERSION=$(echo $GITHUB_SHA | cut -c1-7)" >> $GITHUB_ENV

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ secrets.REGISTRY_USER }}/marketplace:${{ env.VERSION }}
            ghcr.io/${{ secrets.REGISTRY_USER }}/marketplace:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            VCS_REF=${{ github.sha }}
            VERSION=${{ env.VERSION }}

  deploy:
    name: Deploy to VPS
    needs: build_and_push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Create .env file
        env:
          ENV_FILE: ${{ secrets.ENV_FILE }}
        run: |
          echo "$ENV_FILE" > .env

      - name: Create backup directory
        run: |
          mkdir -p backups scripts nginx/ssl nginx/logs
          chmod -R 777 backups

      - name: Create backup script
        run: |
          cat > scripts/backup.sh << 'EOF'
          #!/bin/bash
          
          # Создаем директорию для резервных копий, если она не существует
          mkdir -p /backups
          
          # Устанавливаем имя файла с датой
          BACKUP_FILE="/backups/marketplace_$(date +%Y%m%d_%H%M%S).sql"
          
          # Выполняем резервное копирование
          echo "Creating backup to $BACKUP_FILE"
          pg_dump -h $PGHOST -p $PGPORT -U $PGUSER -d $PGDATABASE -F c -b -v -f "$BACKUP_FILE"
          
          # Удаляем старые резервные копии (оставляем только 7 последних)
          echo "Cleaning old backups..."
          ls -tp /backups/*.sql | grep -v '/$' | tail -n +8 | xargs -I {} rm -- {}
          
          echo "Backup completed successfully!"
          
          # Ждем 24 часа перед следующим резервным копированием
          echo "Waiting for next backup cycle..."
          sleep 24h
          
          # Перезапускаем скрипт
          exec "$0"
          EOF
          chmod +x scripts/backup.sh

      - name: Deploy to VPS via SSH
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            # Переходим в директорию проекта
            cd /opt/marketplace
            
            # Создаем нужные директории если не существуют
            mkdir -p backups scripts nginx/ssl nginx/logs
            
            # Устанавливаем переменную для имени образа
            export APP_IMAGE="ghcr.io/${{ secrets.REGISTRY_USER }}/marketplace:latest"
            
            # Логинимся в GitHub Container Registry
            echo ${{ secrets.REGISTRY_PASS }} | docker login ghcr.io -u ${{ secrets.REGISTRY_USER }} --password-stdin
            
            # Делаем резервную копию базы данных перед обновлением
            echo "Creating database backup before update..."
            docker-compose exec -T db pg_dump -U postgres -d marketplace -F c -f /tmp/pre_update_backup.sql
            docker cp $(docker-compose ps -q db):/tmp/pre_update_backup.sql ./backups/pre_update_$(date +%Y%m%d_%H%M%S).sql
            
            # Копируем загруженные файлы из контейнера в хостовую систему (если используется)
            if [ "$(docker-compose ps -q app)" != "" ]; then
              echo "Backing up uploads directory..."
              docker cp $(docker-compose ps -q app):/app/uploads ./uploads_backup_$(date +%Y%m%d_%H%M%S)
            fi
            
            # Обновляем образы
            docker-compose pull
            
            # Перезапускаем контейнеры
            docker-compose up -d --remove-orphans
            
            # Проверяем статус
            docker-compose ps
            
            # Очищаем неиспользуемые образы
            docker image prune -f
            
            # Выходим из реестра Docker
            docker logout ghcr.io
            
            # Проверяем работоспособность приложения
            echo "Checking application health..."
            max_attempts=10
            attempt=0
            while [ $attempt -lt $max_attempts ]; do
              if curl -s http://localhost/health | grep -q "OK"; then
                echo "Application is healthy!"
                break
              fi
              attempt=$((attempt+1))
              echo "Waiting for application to be healthy... (attempt $attempt/$max_attempts)"
              sleep 10
            done
            
            if [ $attempt -eq $max_attempts ]; then
              echo "Application failed health check after $max_attempts attempts!"
              exit 1
            fi 